package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

type StructDef struct {
	Name   string
	Fields map[string]string
	Order  []string
}

var structs = map[string]*StructDef{}

func main() {
	// Step 1: Read from input.json
	jsonBytes, err := ioutil.ReadFile("input.json")
	if err != nil {
		fmt.Println("Error reading input.json:", err)
		os.Exit(1)
	}

	var data map[string]interface{}
	err = json.Unmarshal(jsonBytes, &data)
	if err != nil {
		fmt.Println("Invalid JSON:", err)
		os.Exit(1)
	}

	// Step 2: Convert to struct definition
	parseObject("AutoGenerated", data)

	// Step 3: Generate Go code
	var builder strings.Builder
	builder.WriteString("package main\n\n")

	// Print all nested structs first
	for name, s := range structs {
		if name == "AutoGenerated" {
			continue
		}
		writeStruct(&builder, s)
	}

	// Print main struct last
	writeStruct(&builder, structs["AutoGenerated"])

	// Step 4: Save to models.go
	err = os.WriteFile("models.go", []byte(builder.String()), 0644)
	if err != nil {
		fmt.Println("Failed to write models.go:", err)
		os.Exit(1)
	}

	fmt.Println("âœ… Structs generated and saved to models.go")
}

func parseObject(structName string, data map[string]interface{}) {
	s := &StructDef{
		Name:   structName,
		Fields: make(map[string]string),
		Order:  []string{},
	}
	for key, value := range data {
		fieldName := toCamelCase(key)
		fieldType := detectType(fieldName, key, value)
		s.Fields[fieldName] = fmt.Sprintf("%s `json:\"%s\"`", fieldType, key)
		s.Order = append(s.Order, fieldName)
	}
	structs[structName] = s
}

func detectType(fieldName, jsonKey string, value interface{}) string {
	switch v := value.(type) {
	case string:
		return "string"
	case float64:
		if v == float64(int64(v)) {
			return "int"
		}
		return "float64"
	case bool:
		return "bool"
	case []interface{}:
		if len(v) == 0 {
			return "[]interface{}"
		}
		switch first := v[0].(type) {
		case map[string]interface{}:
			nestedName := singularize(fieldName)
			parseObject(nestedName, first)
			return "[]" + nestedName
		default:
			return "[]" + detectType(fieldName, jsonKey, first)
		}
	case map[string]interface{}:
		nestedName := fieldName
		parseObject(nestedName, v)
		return nestedName
	default:
		return "interface{}"
	}
}

func writeStruct(b *strings.Builder, s *StructDef) {
	b.WriteString(fmt.Sprintf("type %s struct {\n", s.Name))
	for _, field := range s.Order {
		b.WriteString(fmt.Sprintf("\t%s %s\n", field, s.Fields[field]))
	}
	b.WriteString("}\n\n")
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		parts[i] = strings.Title(parts[i])
	}
	return strings.Join(parts, "")
}

func singularize(s string) string {
	if strings.HasSuffix(s, "s") {
		return s[:len(s)-1]
	}
	return s
}
